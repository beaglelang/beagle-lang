initSidebarItems({"enum":[["TyValueElement","An element of a [TyValue].  This has to do with primitive data since primitives are built in. This also allows for convenience when checking for non-primitives types. If you have a class called `A`, then the TyValueElement for `A` would be `TyValueElement::Custom(\"A\"). This will then be used during type checking to ensure that Values such as calling A's constructor is matched with the required type of the statement. `let a = A()`"]],"struct":[["Identifier","A part of an IR that contains an identifier."],["Mutability","A part of a local or property whichi contains information about it's mutability. Properties use `var` while locals use `let mut`."],["Ty","A type, the meat of the sandwhich. Ty represents a type which is used to represent a specific type. Type info is generated or inferred by context. A Ty can be inferred or generated depending upon building blocks or sister componenets. Smart casting using the given context to ensure that while within a conditional block that checks for a type's instance, that we safely cast an object's type to the checked type. ` if(a is B){      //Object 'a' was checked in the condition against the type B, so therefore we can safely smart cast 'a' to type B.      a.doSomething()  }`"],["TyValue","A value from input and it's type. This can include primitive data such as literals, Unit values (aka, void or nothing), or custom types when parsing Constructors. See [TyValueElement] for more information."],["Typeck","A single instance of a type checker, thus the shortened name Typeck. Each file is given its own Typeck.  Explicit source module declarations are part of the IR and are not given their own typecks. Example: ```  //This is part of its parent module's typeck and will be represented internally as a `Module` instead of being given its own typeck.  mod A{"],["TypeckManager","A global manager for all [typeck]s. All typeck's are added to a threadpool upon a call to [enqueueModule]. A single notice send channel is shared between all typeck's. The flow of notices currently is temporary but looks something like this `           ^            |      TypeckManager      /     |     \\     /      |      \\  Typeck  Typeck  Typeck` TODO:  * Implement notices stack and a global error handling system.       * This will require that upon an error being emitted by a typeck, the manager will emit a shut down message to the compiler driver, which will commence a global shutdown process.  * Implement an intertypeck messaging system      * This will allow each individual typeck's to send a message to the manager which will send the message's payload to the targeted module/typeck. The payload is a request for type info on a given symbol.          `             struct Message{                  //A CanonicalPath will have methods for acting upon a canonical path. A canonical path would be like `A::B::C`, where each `::` is a path separator. This is used for splitting the module's name from the parent's canonical name.                  module_path: CanonicalPath{                      ident: String                  }                  payload: MessagePayload              }              enum MessagePayload{                   //The identifier of a symbol being requested                  SymbolTyRequest(String),                  //A response to SymboltyRequest where a clone of the symbol's type is attached with the symbol's identifier.                  SymbolTyResponse(String, Ty)              }         `"]],"trait":[["GetTy","A trait that provides a method called `get_ty` which is a convenience method for quickly getting an IR element's type info."],["Load","This trait provides an associated function for loading typeck IR into the current typeck instance. Output is what type is being returned upon success. Due to the fact that traits don't have known sizes at compiletime, an associated type will do. This trait is implemented for different kinds of IR such as a [statements::Statement] or [properties::Property]."]]});